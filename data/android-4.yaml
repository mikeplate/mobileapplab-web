title: Data
description: >
  Store data persistantly in different ways. Learn about data structures in memory and how to store them
  in files and databases. Display rows of data efficiently. 
menu:
- title: Lecture Presentation
  heading: 4. Data
  type: deck
  shortname: lecture
  description: >
    Slides displayed in the browser. Choose "print" link for a printer-friendly
    page with all slides after one another.
  menu:
  - title: Goals
    menu:
    - Store simple values persistantly
    - Know some Java structures for storing multiple items of data
    - Use simple file handling to store and retrieve objects persistantly
    - Display lists of data using ListView and adapters
  - title: SharedPreferences to store simple values
    menu:
    - title: Store a single primitive type or a String persistantly
    - title: A good time
      menu:
      - title: To write the value is whenever the value changes
      - title: To read the value is in the onCreate method of the Activity
    - title: Write a value
      language: java
      code: |
        String name = "Mike";
        SharedPreferences.Editor storage = 
          getSharedPreferences("mydata", MODE_PRIVATE).edit();
        storage.putString("name", name);
        storage.commit();
    - title: Read a value
      language: java
      code: |
        SharedPreferences storage = getSharedPreferences("mydata");
        String name = storage.getString("name", "");
  - title: Static arrays in Java
    menu:
    - title: Arrays are an important part of any programming language for handling multiple instances of data
    - title: Declare and initialize a static Array
      language: java
      code: |
        String[] names = new String[] { "Adam", "Betty", "Carl", "Donna" };
        int nameCount = names.length;
    - title: Iterate through all values in an Array
      language: java
      code: |
        for (int index = 0; index < names.length; index++) {
          Log.i("myapp", "Welcome " + names[index]);
        }
    - title: Static arrays can change value at existing index, but can't add or remove values
  - title: Dynamic arrays in Java
    menu:
    - title: Can add and remove values during the array's lifetime
    - title: Declare and add values
      language: java
      code: |
        ArrayList<String> names = new ArrayList<String>();
        names.add("Adam");
        names.add("Betty");
        names.addAll(Arrays.asList("Carl", "Donna"));
    - title: Iterate through all values in an ArrayList
      language: java
      code: |
        for (int index = 0; index < names.size(); index++) {
          Log.i("myapp", "Welcome " + names.get(i));
        }
    - title: Find and remove a value
      language: java
      code: |
        int found = names.indexOf("Carl");
        if (found>=0)
          names.remove(found);
  - title: Hashes in Java
    menu:
    - title: Hashes are also a common storage object
      menu:
      - title: Values are accessed with a key and not just a sequential index
      - title: Keys are stored in such a way that finding a specific key's value is very fast
      - title: Can also be called maps, hashtables, dictionaries etc
    - title: Declare and add values
      language: java
      code: |
        HashMap<String, String> capitals = new HashMap<String, String>();
        capitals.put("Sweden", "Stockholm");
        capitals.put("Norway", "Oslo");
    - title: Iterate through all values
      language: java
      code: |
        for (String country : capitals.keySet()) {
          Log.i("myapp", "The capital of " + country + " is " + capitals.get(country));
        }
    - title: Remove a value by key
      language: java
      code: |
        capitals.remove("Denmark");
  - title: File system access in Android
    menu:
    - title: Every app has a internal folder where files and subfolders can be created
      description: >
        This folder is protected from other apps (assuming MODE_PRIVATE)
    - title: An app can also request permissions to public storage like an SD card or USB memory
      description: >
        These folders can be accessed from all other apps. Don't store anything sensitive here!
    - title: Retrieve paths to these folders
      language: java
      code: |
        File internal = getFilesDir();
        File external = getExternalCacheDir();
    - title: File class encapsulates both files and directories
  - title: Write and read files
    menu:
    - title: Write to an internal and protected (from other apps) file
      language: java
      code: |
        String namelist = "Adam,Betty,Carl,Donna";
        FileOutputStream file = openFileOutput("data.txt", Context.MODE_PRIVATE);
        file.write(namelist.getBytes());
        file.close();
    - title: Read back from an internal file
      language: java
      code: |
        byte[] buffer = new byte[100];
        FileInputStream file = openFileInput("data.txt");
        int readcount = file.read(buffer);
        file.close();
        String namelist = new String(buffer, 0, readcount);
    - title: File system access exception handling
      menu:
      - title: Most file system calls require exception handling
    - title: Text file classes
      menu:
      - title: Handle byte/binary conversions to/from Strings
  - title: Data Model
    menu:
    - title: Creating a data model means creating your own classes for each type of information
    - title: In its simplest form, the class only contains data members
    - title: For true object orientation, it will also contain methods for performing operations on the object
    - title: Create your own class for a todo/task item
      language: java
      code: |
        public class Task {
          public String title;
          public int priority;
          public Calendar due;

          // Example of a member that calculates a result from existing data member(s)
          public int daysLeft() {
            long ms = due.getTimeInMillis() - GregorianCalendar.getInstance().getTimeInMillis();
            return (int)(ms / 86400);
          }
        }
  - title: Using a data model
    menu:
    - title: Create a new object and set values
      language: java
      code: |
        Task todo = new Task();
        todo.title = "Paint the house";
        todo.priority = 3;
        todo.due = new GregorianCalendar(2013, 7, 1);
    - title: Store multiple objects in an array
      language: java
      code: |
        ArrayList<Task> data = new ArrayList<Task>();
        data.add(todo);
  - title: Object serialization preparation
    menu:
    - title: Dump objects in memory to a file
      description: >
        Useful for persistant storage when the number of objects aren't that many, like a few 100s
    - title: Declare your own class to hold all values for a single data value
    - title: Implement interface Serializable and define a version number
      language: java
      code: |
        public class Task implements Serializable {
          private static final long serialVersionUID = 1;
          // etc ...
        }
  - title: Object serialization to/from binary files
    menu:
    - title: Wrap streams in ObjectOutputStream and ObjectInputStream
    - title: Write an ArrayList with objects of custom class
      language: java
      code: |
        FileOutputStream file = openFileOutput("data.bin", Context.MODE_PRIVATE);
        ObjectOutputStream output = new ObjectOutputStream(file);
        output.writeObject(data);
        output.close();
    - title: Read an ArrayList with objects of custom class
      language: java
      code: |
        FileOutputStream file = openFileOutput("data.bin", Context.MODE_PRIVATE);
        ObjectInputStream output = new ObjectInputStream(file);
        data = (ArrayList<Task>)output.readObject();
        output.close();
  - title: Use a HashMap instead for dynamic data
    menu:
    - title: With a HashMap, each object does not have to contain the exact same data members
    - title: Can still add methods by extending the HashMap with your own class (not shown below)
    - title: Will be a little slower since all data member access is an additional lookup
    - title: Each data member either has to be of the same type, or type conversions must be used extensively
    - title: Using a HashMap to store a Task
      language: java
      code: |
        HashMap<String, String> todo = new HashMap<String, String>();
        todo.put("title", "Paint the house");
        todo.put("priority", "3");
        todo.put("due", "2013-07-01");
  - title: Lists on mobile devices
    menu:
    - title: Lists of items displayed in the user interface are of high importance and use on mobile devices
    - title: Both Android and iOS have specific feature for dealing with long lists
    - title: Virtual lists
      menu:
      - title: >
          Not efficient on mobile to have all data items in a list/table transformed into visual elements
          in the user interface
      - title: >
          A virtual list is a feature where the system handles scrolling and knowing exactly which data
          items is enough to be visible at any particular point in time
      - title: Items not visible any more (from scrolling etc) are automatically freed from memory
      - title: >
          Visual elements can be reused when scrolling to new data items so they don't have to be
          recreated repeatedly
  - title: Objects for virtual lists
    menu:
    - title: ListView
      menu:
      - title: The visual element in the user interface that handles display, scrolling etc
      - title: Knows which items in the list are currently visible on screen
      - title: Never extended or customized by you
    - title: Data source - for example an ArrayList<String>
      menu:
      - title: Some sort of data storage mechanism that is capable of storing multiple items of data
      - title: Never handled directly by the ListView
      - title: Use a built in data storage class/concept
    - title: Adapter - connects the ListView to the data
      menu:
      - title: Abstraction of the data source so that the same ListView can handle many different types of data storage
      - title: ListAdapter base class is extended into specific adapters for some types of data storage
      - title: Often extended and customized by you to give you full control of how your data items are displayed
  - title: Built-in resources for ListAdapters
    menu:
    - title: Specify a layout xml file
      menu:
      - title: android.R.layout.simple_list_item_1
        description: >
          Built-in layout with a single TextView
      - title: android.R.layout.simple_list_item_2
        description: >
          Built-in layout with one larger and one smaller TextView below each other
    - title: Specify id of TextView inside of layout
      menu:
      - title: android.R.id.text1
        description: >
          Single TextView in android.R.layout.simple_list_item_1 or the larger first TextView in
          android.R.layout.simple_list_item2
      - title: android.R.id.text2
        description: >
          Second smaller TextView in android.R.layout.simple_list_item_2
  - title: Show a single string as ListView item
    menu:
    - title: ArrayAdapter
      menu:
      - title: Handle an array of strings and show the string as the ListView item
      - title: Choice of letting the adapter store the strings too, or keep them in a separate ArrayList
      - title: Actually can contain any object type and will use toString to get the text to display for a single item
    - title: Example
      language: java
      code: |
        ArrayAdapter<String> data = new ArrayAdapter<String>(this, 
          android.R.layout.simple_list_item_1);
  - title: Show two strings as ListView item
    menu:
    - title: SimpleAdapter
      menu:
      - title: Handle an array of HashMap objects and show two strings (title/subtitle) as the ListView item
      - title: HashMaps are a simple construct in Java to store key/value combinations in an object
      - title: Must store actual data separately
      - title: Don't be scared by all the < and > when dealing with Java Arrays and HashMaps
      - title: Maps two properties on the object to visual elements in the item view
    - title: Example
      language: java
      code: |
        ArrayList<HashMap<String, String>> data = new ArrayList<HashMap<String, String>>();
        HashMap<String, String> person = new HashMap<String, String>();
        person.put("name", "Adam");
        person.put("desc", "From Sweden");
        SimpleAdapter adapter = new SimpleAdapter(this, data, android.R.layout.simple_list_item_2,
          new String[] { "name", "desc" }, new int[] { android.R.id.text1, android.R.id.text2 });
  - title: Show customized ListView item
    menu:
    - title: Extend your own class from existing adapter like ArrayAdapter or BaseAdapter
      menu:
      - title: Handle an array but override methods to customize the item view and its displayed data
      - title: Can actually extend other adapters too, if better suited to your storage preference
      - title: Must manually handle defining and creating the item view, and setting its contents from the data
    - title: Example of framework (methods on next slide)
      language: java
      code: |
        public class MyData {
          public String title;
        }
        public class MyDataAdapter extends ArrayAdapter<MyData> {
          int _layoutId;
          public MyDataAdapter(Context context, int layoutId) {
            super(context);
            _layoutId = layoutId;
          }
        }
        MyDataAdapter adapter = new MyDataAdapter(this, R.layout.item);
  - title: Show customized ListView item
    menu:
    - title: Override the getView method
      menu:
      - title: Called by framework when an item view needs to be created
      - title: Reuses item views so you should only change the properties of existing item views if possible
      - title: View already exists if View argument is non-null
    - title: Example, code inside MyDataAdapter
      language: java
      code: |
        @Override
        public View getView(int position, View existing, ViewGroup parent) {
          if (existing==null)
            existing = LayoutInflater.from(getContext()).inflate(_layoutId, null);
          MyData itemData = getItem(position);
          TextView title = (TextView)existing.findViewById(R.id.title);
          title.setText(itemData.title);
          return existing;
        }
  - title: Creating views from a layout xml file in Java
    menu:
    - title: Android calls the process of creating View objects from an xml layout file "inflating"
    - title: This has already happened in your call to setContentView
    - title: Easy to do yourself too
      language: javascript
      code: |
        LayoutInflater helper = getLayoutInflater();
        View allViews = helper.inflate(R.layout.some_layout_xml_file);
  - title: AlertDialog
    menu:
    - title: Show a simple message dialog on screen with Ok and Cancel buttons
      language: java
      code: |
        AlertDialog.Builder dlg = new AlertDialog.Builder(this);
        dlg.setTitle("Confirm deletetion");
        dlg.setMessage("Are you sure you want to delete this?");
        dlg.setNegativeButton(android.R.string.cancel, null);
        dlg.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
          void onClick(DialogInterface iDlg, int which) {
            performDeleteAction();
          }
        });
        dlg.show();
  - title: AlertDialog with input field
    menu:
    - title: Create any custom view in Java and set it as the contents of the AlertDialog
      language: java
      code: |
        AlertDialog.Builder dlg = new AlertDialog.Builder(this);
        final EditText content = new EditText(this);
        dlg.setTitle("Confirm deletetion");
        dlg.setView(content);
        dlg.setNegativeButton(android.R.string.cancel, null);
        dlg.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
          void onClick(DialogInterface iDlg, int which) {
            doSomethingWithString(content.getText().toString());
          }
        dlg.show();
  - title: AlertDialog with a full custom layout
    menu:
    - title: Create a custom layout for your Dialog from a layout xml resource file
      language: java
      code: |
        AlertDialog.Builder dlg = new AlertDialog.Builder(this);
        View layout = getLayoutInflater().inflate(R.layout.person_form);
        final EditText firstname = (EditText)layout.findViewById(R.id.firstname);
        final EditText lastname = (EditText)layout.findViewById(R.id.lastname);
        dlg.setTitle("Tell me your name");
        dlg.setView(layout);
        dlg.setNegativeButton(android.R.string.cancel, null);
        dlg.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
          void onClick(DialogInterface iDlg, int which) {
            savePerson(firstname.getText().toString(), lastname.getText().toString());
          }
        dlg.show();

- title: Exercises
  expand: true
  description: Practical tasks to perform and ensure that the basis of the chapter has been understood.
  menu:
  - title: Assignment, mandatory
    description: >
      The assignment is mandatory for a passing grade in the course.
    menu:
    - title: Store in SharedPreferences
      description: >
        Add persistant storage to previous assignments Summarizer and Conversion using SharedPreferences.
        You must perform both of the following tasks to complete the assignment.
      menu:
      - title: >
          Add persistant storage to the previous mandatory assignment from chapter 1 called Summarizer.
          Use the SharedPreferences API on Android to store the current total in the application, and
          read it back when the application starts.
      - title: >
          Add persistant storage to the previous mandatory assignment from chapter 3 called Conversion.
          Use the SharedPreferences API to store the current value of the SeekBar, and read it back when
          the application starts (and set the position of the SeekBar accordingly).
  - title: Assignment, optional
    description: >
      Perform this optional assignment to get one (1) extra credit.
    menu:
    - title: Prices
      description: >
        Create an application that stores products and prices in a list.
      menu:
      - title: >
          Create a layout with a ListView, two EditText elements and a Button. The two EditText elements
          shall be used to specify a product name and a product price. The Button shall be used to add
          new products to the list.
      - title: >
          Organize the elements in any way you like and feel free to add TextViews to show a label
          for the EditText elements if you like. Style them and use any kind of nested
          LinearLayouts in order to show them nicely in the user interface. The ListView should be
          set to extend to whatever height remains in the application after the other elements
          have been layed out.
      - title: >
          Use a class capable of storing a "name" and a "price" for the products in the application.
          Preferably use an object of type HashMap<String, String> and store the price as a string too.
          Create a class member of type ArrayList<HashMap<String, String>> to store all added products.
      - title: >
          When the user presses the Button, a new product object should be created and have its name
          and price set from the EditText elements. Add the new object to the storage object that
          you created in the previous step.
      - title: >
          Make sure that everything in the ArrayList (all products) is persistantly stored using
          object serialization. Everything a product is added, you should save all objects to disk.
          And when the application starts, you should read all objects from disk so that they are
          displayed when the application appears on screen.
      - title: >
          Use a SimpleAdapter for the ListView to display the products. You shall use a custom layout xml
          resource that you define which contains a place for both the name of the product and the price
          of the product. The price should be right-aligned and placed to the right of the name. The
          exact layout and styling is not important. Make sure that whenever a new product is added,
          the SimpleAdapter is notified so that it appears on screen.
      - title: >
          Note that your app does NOT have to support editing or deleting of products. Just adding and
          displaying the products is enough to complete the assignment.

#- title: ListApp Example
#  description: >
#    Keep a list of categorized items. Categories can be added, as can items within those categories so the
#    data could be almost anything but it is somewhat streamlined as a todo-list. Demonstrates the ListView
#    visual element and persisting multiple data values in storage.

